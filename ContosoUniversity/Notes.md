# Getting Started with Entity Framework 6 using MVC 5

#### Source
[Entity Framework 6]
(http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application "Microsoft ASP.NET")

## 1. Creating and Entity Framework Data Model


This section explains how the new project is set up.

#### 1.1 Initial Setup

Unlike the *MvcMovie* project, where the ability for users to log in was assumed
(but not implemented), this project explicitly removes the rewquirement that users
should log in. Thus, while creating the project, when a template is being chosen
in the New Project wizard, the authentication is removed by clicking the 
*Change Authentication* button and selecting the *No Authentication* option in the
next window.

#### 1.2. Install Entity Framework

If EF is missing, install it as follows:

1. Open Tools > Library/NuGet Package Manager > Package Manager Console
2. In the Package Manager Console, run the following command:

```
Install-Package EntityFramework
```

#### 1.3. Creating the Models

Models in an MVC application represent the data that will be used and persisted
to the database. The models have two kinds of properties:

* Those that are unique to the model. These represent the attributes of the model
itself. By default, any named *ID* or *classNameID* is used as the primary key
in the database. Using *ID* makes it easier to implement inheritance. Either way,
whichever mode is picked should be the one consistently used throughout.

* Those used to show an association/ a relationship between two models/entities.
Such properties are known as **_Navigation Properties_**. A navigation property
holds other entities that are related to this entity. Each relationship 
between models is defined by two ends, describing the entity type and the 
multiplicity of the type (one, zero-or-one, or many). Common relationships include
*one-to-many*, *one-to-one* and *many-to-many*.

The models used are as follows:

**(a). The Student Entity**

Each `Student` has a unique identifier, as well as properties to hold the name 
and enrollment date. A `Student` can have several `Enrollments`, which is, here,
a way to define the relationship between a `Student` and a `Course`. Having
multiple `Enrollment` objects shows that a single student can enroll in multiple
courses.

```c#
public class Student
{
    public int ID {  get; set; }    // primary key
    public string LastName { get; set; }
    public string FirstMidName { get; set; }
    public DateTime EnrollmentDate { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```

Navigation properties are typically declared as `virtual`, to take advantage of
Entity Framework functionality such as *lazy loading*. If a navigation property
can hold multiple entities (such as a many-to-many or one-to-many relationships),
then its type must be a list allowing CRUD operations.

**(b). The Enrollment Entity**

As noted earlier, `Enrollment` defines the relationship between a `Student` and
a `Course`. Each `Enrollment` object has a unique identifier and a `Grade`. It 
also holds references to the `Student` and `Course` objects that together create
this `Enrollment`; the `ID` fields of each are the foreign keys for each 
`Enrollment` item into its respective `Student` and `Course` rows. 

```c#
public enum Grade
{
    A, B, C, D, F
}
public class Enrollment
{
    // primary key
        public int ID { get; set; }
 
        // nullable; null grade != zero grade
        public Grade? Grade { get; set; }

        // foreign keys
        public int CourseID { get; set; }   
        public int StudentID { get; set; } 

        // navigation properties
        // one-to-one relationship with both
        public virtual Course Course { get; set; } 
        public virtual Student Student { get; set; }
}
```

Entity Framework interprets a property as a foreign key if its name follows the
syntax *< navigation property name > < primary key property name >*, e.g. `StudentID`
for the `Student` navigation property, since `Student` is the navigation property
name, and `ID` is the primary key of `Student`. An alternative syntax used for
classes that use *classNameID* as the primary key is *< primary key property name >*,
(since the first format would result in, for instance, `StudentStudentID` if the
primary key of the `Student` model was `StudentID`).

**(c). The Course Entity**

The `Course` entity contains a unique identifier, a title and credits. It has a
reference to the collection of `Enrollment` objects that would include it, since
multiple students are allowed to enrol in any one course.

```c#
public class Course
{
    // primary key; have it not automatically generated by database.
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int ID { get; set; }

    public string Title { get; set; }
    public int Credits { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```
A view of all three models is as below: the second row in the table shows the
relationship of each entity to the one on its right (i.e. one-to-many and 
many-to-one)

| Course (one)  |Enrollment (many)  |Student (one)           |
|---------------|-------------------|------------------------|
| *Properties*  | *Properties*      | *Properties*           |
| int ID (PK)   | int ID (PK)       | int ID                 |
| string Title  | int CourseID (FK) | string LastName        |
| int Credits   | int StudentID (FK)| string FirstMidName    |
|               | Grade Grade       | DateTime EnrollmentDate|
|  *Nav Prop*   | *Nav Props*       | *Nav Prop*             |
| (ICollection) | Course Course     | (ICollection)          |
| Enrollments   | Student Student   | Enrollments            |


#### 1.4. Creating the Database Context

The database context class for this project will be *DataAccessLayer/SchoolContext*,
and will be as follows:

```c#
public class SchoolContext : DbContext
{
    public DbSet<Student> Students { get; set; }
    public DbSet<Enrollment> Enrollments { get; set; }
    public DbSet<Course> Courses { get; set; }

    public SchoolContext()
        : base("SchoolContext")
    { }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Conventions.Remove<PluralizingTableNameConvention>();
    }
}
```

**(a). Specifying entity sets**

The context creates a `DbSet` property for each *entity set*. In EF terminology,
an *entity set* typically corresponds to a database table, while an *entity*
corresponds to a row in the table.

The `Enrollment` and `Course` entity sets could have been left out, as EF would
have automatically created them since `Student` has references to `Enrollment`,
which in turn references `Course`.

**(b). Specifying the connection string**

The name of the database (which we'll also add to *Web.Config* later) is passed
as a parameter to the `DbContext` constructor. If one is not specified, EF assumes
that the connection string name is the same as the class name of the DbContext
(here, `SchoolContext`).

**(c). Specifying singular table names**

The `modelBuilder.Conventions.Remove` call prevents table names from being
pluralized, which is the usual onvention within ASP.NET. Hence the table names
will be `Student`, `Course` and `Enrollment` rathert han their plural versions.
This is merely a coding preference.

#### 1.4. Set Up EF Database Initialization

EF can automatically create (after an optional drop) a database. One can specify
that this happen when the application is run, or only when the model is out of
sync with the existing database, or only if no database exists (default). 

Here, we specify that the db be dropped and recreated any time the model changes.
This is ok in development, because the `Seed` method is called each time to
populate the db with the initial data. However, in production, *database migration*
is commonly used to update the database to the current schema, rather than dropping
the db and losing all data.

The database initialization code is placed in *DataAccesslayer/SchoolInitializer.cs*,
and is as follows:

```c#
public class SchoolInitializer : System.Data.Entity.DropCreateDatabaseIfModelChanges<SchoolContext>
{
    protected override void Seed(SchoolContext context)
    {
        // create list of students
        var students = new List<Student>
        {
            new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},
            new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}
        };

        // add each student to the related dbset
        students.ForEach(s => context.Students.Add(s));

        // persist the changes to the database
        context.SaveChanges();
        // we can leave the SaveChanges() call to the very end, but done here
        // out of an overabundance of caution.

        // repeat with courses
        var courses = new List<Course>
        {
            new Course{ID=1050,Title="Chemistry",Credits=3,},
            new Course{ID=4022,Title="Microeconomics",Credits=3,},
            new Course{ID=2042,Title="Literature",Credits=4,}
        };

        courses.ForEach(s => context.Courses.Add(s));

        context.SaveChanges();

        // and with enrollments
        var enrollments = new List<Enrollment>
        {
            new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},
            new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},
            new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},
            new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},
            new Enrollment{StudentID=3,CourseID=1050}
        };

        enrollments.ForEach(s => context.Enrollments.Add(s));

        context.SaveChanges();
    }
}
```

The `Seed` method takes the database context as a parameter, and the code uses
that context to add records to the database. For each entity type, the code creates
a list of entities, adds them to the appropriate DbSet property, then saves the
changes in the database. While it's not necessary to call `SaveChanges()` after
each entity set, calling it as we've done makes it easier to locate exceptions
that occur while the code is writing to the database.

Once the initializer is created, EF needs to be told to use it. The following
element is added to the `entityFramework` node in *Web.config*

```xml
<entityFramework>
    <contexts>
      <context type="ContosoUniversity.DataAccessLayer.SchoolContext, ContosoUniversity">
        <databaseInitializer type="ContosoUniversity.DataAccessLayer.SchoolInitializer, ContosoUniversity" />
      </context>
<!-- snippet -->
</entityFramework>
```

The `context type` specifies the fully qualified context class name and the
assembly it's in, while `databaseInitlizer type` does the same for the database
initializer class that contains the `Seed()` method. For more information on the
EF configuration settings, see [EF Config File Settings](http://msdn.microsoft.com/en-us/data/jj556606)

The application is now set up such that when you access the database for the 
first time in a given run, EF compares the database to the model (i.e. to the
`SchoolContext` schema and model classes) and if differences exist, it drops and
recreates the database.

> **Note**
> Obviously, deleting data and reseting the database to the base snapshot is
> discourageed in production environments. This tutorial will disable this
> initialization in later stages.

#### 1.5. Set up EF to use a SQL Express LocalDB Database

*LocalBD* is a lightweight version of *SQL Server Express* database engine. It
acta as an easy-to-set-up development database. To use it, add the following line
to *Web.Config*, preceding the `appSettings` element:

```xml
<connectionStrings>
    <add name="SchoolContext" connectionString="Data Source=(LocalDb)\v11.0;Initial Catalog=ContosoUniversity1;Integrated Security=SSPI;" providerName="System.Data.SqlClient"/>
</connectionStrings>
```

This specifies that EF is to use a LocalDB database named *ContosoUniversity1.mdf*.
If the database is to be created in the *App_Data/* folder, one could add the line
`AttachDBFileName=|DataDirectory|\ContosoUniversity1.mdf`.

#### 1.6. Creating a Student Controller and Views

To create the controller:

1. Right-click the *Controllers* folder, select Add > New Scaffolded Item
2. In the *Add Scaffold* dialig box, select *MVC 5 Controller with views, using*
*Entity Framework*
3. In the *Add Controller* dialog box, select the following options
    * Controller name: *StudentControler*
    * Model class: *Student (ContosoUniversity.Models)* (If you don't see this
    option in the dropdown list, build the project and try again).
    * Data context class: *SchoolContext (ContosoUniversity.DataAccessLayer)*
    * Leave the default values for the other fields.
4. Click *Add*

EF creates the *StudentController* class, while scaffolding creates the views of
the basic CRUD operations.

#### 1.7. Conventions

One of the reasons EF requires such minimal code is the conventions it has, which
allow it to make expectations of what the program structure would look like. A
few of those seen so far include:

1. The pluralized forms of entity/model class names are used as the table names
2. Entity/model property names become column names and form labels
3. Entity properties named *ID* or *classNameID* are used as the primary key.
4. Foreign keys are the properties whose names are formatted as follows:
*[ navigation property name ]* *[ navigation property primary key name]* (for 
instance, the `StudentID` property in *Models/Course.cs*, since `Student` is the
navigation property's name and `ID` is the name of the primary key of `Student`),
or the format *[ navigation property primary key name ]* if the primary key uses
the *classNameID* format for its primary key.


---


## 2. Implementing Basic CRUD Functionality


This section creates the views and controller actions required to correctly edit
and display the `Student` entities.

#### 2.1. Create a Details Page

The `Details()` action in StudentController is as shown below:

```c#
// GET: Students/Details/5
public ActionResult Details(int? id)
{
    if (id == null)
    {
        return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
    }
    Student student = db.Students.Find(id);
    if (student == null)
    {
        return HttpNotFound();
    }
    return View(student);
}
```

It finds a student matching the passed ID parameter and sends it to the Details
view. Since the `Student.Enrollments` property is a collection, the view does
not display it. In order to show the enrollments, the following code is added to
the *Details* view:

```cshtml
<!-- snippet -->
<dd>
    @Html.DisplayFor(model => model.EnrollmentDate)
</dd>

<!-- Add this code to display a list of enrollments -->

<dt>
    @Html.DisplayNameFor(model => model.Enrollments)
</dt>
<dd>
    <table class="table">
        <tr>
            <th>Course Title</th>
            <th>Grade</th>
        </tr>
        @foreach (var item in Model.Enrollments)
        {
            <tr>
                <td>
                    @Html.DisplayFor(modelItem => item.Course.Title)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.Grade)
                </td>
            </tr>
        }

    </table>
</dd>
```

The code loops though the `Enrollment` entity for each student, and displays the
courtse title and grade for each.

#### 2.2. Update the Create Page

Change the `Create` action to the following code:

```c#
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create([Bind(Include = "LastName,FirstMidName,EnrollmentDate")] Student student)
{
    try
    {
        if (ModelState.IsValid)
        {
            db.Students.Add(student);
            db.SaveChanges();
            return RedirectToAction("Index");
        }
    }
    catch(DataException /*dex */)
    {
        // log the error (uncommnet dex variable and add line here to log
        ModelState.AddModelError("", "Unable to save changes. Try again, or see your sysadmin");
    }

    return View(student);
}
```

We've removed the `ID` parameter from the *Bind* attribute, and wrapped the rest
of the code in a `try-catch` block. `ID` is removed because it is the primary key
and is automatically generated by the database. The `try-catch` adds some robustness
to the application, since `DataException` errors are sometimes caused by factors
external to the application.

#### 2.3. Update the Edit HttpPost Page

Change the `[HttpPost]` version of the `Edit` action to be:

```c#
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Edit([Bind(Include = "ID,LastName,FirstMidName,EnrollmentDate")] Student student)
{
    try
    {
        if (ModelState.IsValid)
        {
            db.Entry(student).State = EntityState.Modified;
            db.SaveChanges();
            return RedirectToAction("Index");
        }
    }
    catch (DataException /*dex */)
    {
        // log the error (uncommnet dex variable and add line here to log
        ModelState.AddModelError("", "Unable to save changes. Try again, or see your sysadmin");
    }

    return View(student);
}
```

Here, rather than adding the changed user to the database, the code sets a flag
on the entity indicating that the `Student` entity has been modified. When the
`SaveChanges()` method is called, the `Modified` flag causes EF to create SQL
code to update the row. All columns, including those not changed, will be updated,
and *concurrency conflicts* are ignored.

#### 2.3. Update the Delete Page

Much like the `Edit` and `Create` actions, delete operations require two action
methods. The first one, in response to a `GET`, displays a view that allows the
user to confirm or cancel the operation. If the operation is approved, the `POST`
request is created, and invokes the `HttpPost` version of the method.

The changes here will wrap the deletion in a `try-catch`. If an error s found,
the user is redirected to the `Get` version of the page and an error message 
displayed.

Repalce the `Get` version of `Delete` with the following:

```c#
// GET: Students/Delete/5
public ActionResult Delete(int? id, bool? saveChangesError = false)
{
    if(id == null)
    {
        return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
    }
    if(saveChangesError.GetValueOrDefault())
    {
        ViewBag.ErrorMessage = "Delete failed. Try again, or see your sysadmin";
    }

    Student student = db.Students.Find(id);
    if(student == null)
    {
        return HttpNotFound();
    }


    return View(student);
}
```

The method accepts an optional parameter that indicated whether the method was
called after a failure to save changes; the default vbalue is `false`. Being
a *nullable* value (as indicated by the `?` xcter in `bool? saveChangesError...`),
the code `saveChangesError.GetValueOrDefault()` method is used to return the
value of the variable.

Replace the `Post` version (here, `DeleteConfirmed()`) with the following:

```c#
// POST: Students/Delete/5
[HttpPost, ActionName("Delete")]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        // log the error after uncommenting the dex variable name
        return RedirectToAction("Delete", new {id = id, saveChangesError = true });
    }
    
    return RedirectToAction("Index");
}
```

Note that the name is now changed to `Delete`.

The code retrieves the desired entity, calls `Remove` on the context using that 
entity, then saves the changes (here, an SQL `DELETE` command is generated). If 
this operaton fails due to a `DatException` error, the caller is redirected to
the `Get` version of the `Delete` call with a new object holding the id and error
message.

This method generated SQL that may be constly in some applications. Tis may be
repalced with:

```c#
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
```

To complete the `Delete` code, add the following to the *Delete* view:

```cshtml
<!-- snippet -->
<h2>Delete</h2>
<p class="error">@ViewBag.ErrorMesage</p>
<h3>Are you sure you want to delete this?</h3>
<!-- snippet -->
```

#### 2.4. Closing/Disposing of Database Connections

To ensure all database connections are closed and resources freed, the context
instance must be disposed of once we're done with it. This is done by the `Dispose`
method at the end of the `StudentController` class, as shown:

```c#
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        db.Dispose();
    }
    base.Dispose(disposing);
}
```

The base `Controller` class already implememnts the `IDisposable` interface, so
this call simply acts as an override.

#### 2.5. Handling Transactions

EF automatically makes all transactions atomic; either all operations in the
transactions succeed, or all fail.

---


## 3. Add Sorting, Filtering and Pagination

This section adds the capability to sort and group students, as well as paginate
throuh the application.

#### 3.1. Add Sorting Functionality to the Students Index page

Replace `StudentController/Index()` wit the following code:

```c#
// GET: Students
public ActionResult Index(string sortOrder)
{
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";

    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    var students = from s in db.Students
                   select s;

    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    return View(students.ToList());
}
```

The method receives a parameter `sortOrder` as a query string; this parameter is
a string containing either "*Name*" or "*Date*", optionally followed by "*_desc*"
to specify descending order. The default sorting format is by last name, ascending.

When the `Index` method is called the first time, the sort parameter is empty, 
and the students are displayed in ascending order by `Lastname`. When a user
clicks on the column heading hyperlink (as implemented below), then the
appropriate `sortOrder` value is provided.

The ViewBag variables are used to allow the view to configure the column heading
hyperlinks.

The code uses LINQ to create the `IQueryable` variable, then the switch to 
determine the filter, and calls `ToList` to execute the query and pass the
resultant list to the view. Note that, unlike the original `Index` method which
returned `View(db.Students.ToList())` (i.e. a list of all the students, sans
filtering), this one returns `View(students.ToList())`, the (possibly filtered)
LINQ query. 

Change the *Index* view to be as follows:

```cshtml
<!-- snippet -->
<p>
    @Html.ActionLink("Create New", "Create")
</p>
<table class="table">
    <tr>
        <th>
            @Html.ActionLink("Last Name", "Index", new object { sortOrder = ViewBag.NameSortParm })
        </th>
        <th>
            First Name
        </th>
        <th>
            @Html.ActionLink("Enrollment Date", "Index", new object { sortOrder = ViewBag.NameSortParm })
        </th>
        <th>
            
        </th>
        <th></th>
    </tr>

@foreach (var item in Model) {

<!-- snippet -->

```

The code uses the information in the `ViewBag` properties to set up hyperlinks 
with the appropriate hyperlink values. This is because the value of the hyperlink
depends on what the last sort order was; the first time `Index` is invoked, 
`sortOrder` is null because no sorting has been asked for, and therefore `Index`
starts off by having `ViewBag.NameSortParm` be set to the sorting option that 
will be possible when the view is displayed (since the view sorts by last name 
ascending - the default setting - the first time `Index` is invoked, the link 
should allow sorting by last name descending, hence `NameSortParm` is set to 
`name_desc`). Similarly, the first time `Index` is invoked, sorting by enrollment
date is yet to be requested, so we set it to one of the available options. Hence
when sorting is invoked by one format, the link is to be set to the opposite
value when the view renders, hence the `ViewBag` property is reset.

#### 3.2. Add a Search Box to the Students Index Page

A search filter requires a textbox and a submit button on the view, and code in
the `Index` to handle the search request. Change it to the code below:

```c#
// GET: Students
public ActionResult Index(string sortOrder, string searchString)
{
    // set the sorting link parameters
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";
    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    var students = from s in db.Students
                   select s;

    // filter by search term
    if(!string.IsNullOrEmpty(searchString))
    {
        searchString = searchString.ToUpper();
        students = students.Where(s => s.LastName.ToUpper().Contains(searchString)
                                    || s.FirstMidName.ToUpper().Contains(searchString) );
    }            
    
    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    return View(students.ToList());
}
```

The change adds a filter to the `students` query if a search term is provided.
This filter is executed on the database itself (i.e. `Contains` is called as an
SQL statement, and is not the .NET `string.Contains(string)` method). Calling it
on the database rather than on an in-memory colection ensures the results are
consistent; .NET's `Contains()` returns all rows if an empty search string is
passed, while SQL's returns no row at all. Hence the search filter is called on
the database for consistency, and called within the `if` to make sure the search
string is not empty.

Change the Index view to the following:

```cshtml
<!-- snippet -->
<p>
    @Html.ActionLink("Create New", "Create")
</p>


@using(Html.BeginForm())
{
    <p>
        Find by name: @Html.TextBox("SearchString")
        <input type="submit" value="Search" />
    </p>
}

<table class="table">
    ...
</table>

<!-- snippet -->

```

The code above calls `BeginForm` to create the form fields required for the search.
Note that the url sent to the controller does not contain the search term within
it; the search terms are sent as a POST request. This will be changed later.

#### 3.3. Adding Paging to the Students Index Page

Start by installing the *PagedList.Mvc*, one of the many paging and sorting
packages for ASP.NET MVC, used here as an example rather than as a recommendation
over other options.

Click *Tools > Library > NuGet Package Manager > Package Manager Console*, and 
type the command below:

```
Install-Package PagedList.Mvc
```

Add `using PagedList` to the *StudentController.cs* file, and replace the `Index`
method with the following code:

```c#
// GET: Students
        public ActionResult Index(string sortOrder, string searchString, string currentFilter, int? page)
{
    ViewBag.CurrentSort = sortOrder;

    // set the sorting link parameters
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";
    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    if(searchString != null)
    {
        page = 1;
    }
    else
    {
        searchString = currentFilter;
    }

    ViewBag.CurrentFilter = searchString;
    
    var students = from s in db.Students
                   select s;

    // filter by search term
    if(!string.IsNullOrEmpty(searchString))
    {
        searchString = searchString.ToUpper();
        students = students.Where(s => s.LastName.ToUpper().Contains(searchString)
                                    || s.FirstMidName.ToUpper().Contains(searchString) );
    }            
    
    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    int pageSize = 3;
    int pageNumber = (page ?? 1);

    return View(students.ToPagedList(pageNumber, pageSize));
}
```

We've added current filter and page parameters to the method signature. The first
time the page is displayed, all 4 parameters will be empty.

Each navigation to a new page will result in a call to the `Index` method. The 
sort order will ahve to be maintained throughout these calls, so the first line
(`Viewbag.CurrentSort = sortOrder`) caches the sort order between views/pages.

The property `Viewbag.CurrentFilter` provides a way to do the same with the
searchString filter. This allows it to be maintained throughout the paging, and 
be restored to the textbox when the page is changed. If the search string is reset
during paging, the page has to be reset to `1`, because the new filter can result
in different data to display (and therefore a different number of pages). Once
a saearch filter is entered and cached by `ViewBag.CurrentFilter`, subsequent
paginations send a null value of searchString, and it is rewritten as the value
of `string currentFilter`. If, however, some search string is entered, then
`searchString` is no longer null, and the page is reset to `1` as shown below:

```c#
if(searchString != null)
{
    page = 1;
}
else
{
    searchString = currentFilter;
}
```

Att he end of the method, the `ToPagedList` extension method on the `students`
`IQueryable` object converts the string query into a single page of students in
a collections that supports paging. This single page is then passed to the view:

```c#
int pageSize = 3;
int pageNumber = (page ?? 1);
return View(students.ToPagedList(pageNumber, pageSize));
```

The `ToPagedList` method takes two parameters; the first is the page number that
the view should report, while the second is the number of items each page can 
have.

> **Note**
> The `??` operator in the line `int pageNumber = (page ?? 1)` is known as the
> *null-coalescing operator*. Basically, it returns the left vale if it's not
> null, else the value on the right. Hence `pageNumber = page` if `page` is not
> null; if it is, then `pageNumber = 1`.

Change the Index view to reflect the changes, as follows:

* Remove the `@Model IEnumerable<ContosoUniversity.Models.Student>` line at the
top of the file.

* Add the following lines to the top of the file.

```cshtml
@model PagedList.IPagedList<ContosoUniversity.Models.Student>
@using PagedList.Mvc;

<link href="~/Content/PagedList.css" rel="stylesheet" type="text/css" />
```

The `@model` statement at the top specifies that the view now gets a `PagedList`
object instead of the `List` object it got before. The `using` statement adds a
reference to the `PagedList.Mvc` helper for the paging buttons.

* Use an overload of `BeginForm` to create a search url that can be bookmarked:

```cshtml
@using (Html.BeginForm("Index", "Student", "FormMethod.Get"))
{
    <p>
        Find by name: @Html.TextBox("SearchString", Viewbag.CurrentFilter as string)
        <input type="submit" value="Search" />
    </p>
}
```

The default `BeginForm` submits values as POSTed route data, rather than as query 
strings. Operations not altering the database or application state, such as
searching, are best called through GET operations.

The text box is initialized with the current search string so that each page has
the search filter value displayed within it when the page loads.

* Add the sorting filters to the column header links, to allow sorting on 
subsequent pages.

```cshtml
@Html.ActionLink("Last Name", "Index", new { sortOrder = Viewbag.NameSortParm, currentFilter = Viewbag.CurrentFilter})
```

* Show the current page and the total number of pages: add this to the bottom of
the file:

```cshtml
Page @(Model.PageCount < Model.PageNumber ? 0 : Model.PageNumber) of @Model.PageCount
```

This displays "Page 0 of 0" of there are no pages to display; `Model.PageNumber`
will be 1 (this is the lowest it can be, even if no results matching the search
filter are found), while `Model.PageCount` will be 0.

* Display the paging buttons; add the following code after the line above;

```cshtml
@html.PagedListPager(Model, page => Url.Action("Index", new { page }))
```

We can optionally have the `new { page }` portion include other values, and be
`new { page, sortOrder = ViewBag.CurrentSort, currentFilter = ViewBag.CurrentFilter }`.


