# Getting Started with Entity Framework 6 using MVC 5

#### Source
[Entity Framework 6]
(http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application "Microsoft ASP.NET")

## 1. Creating and Entity Framework Data Model


This section explains how the new project is set up.

#### 1.1 Initial Setup

Unlike the *MvcMovie* project, where the ability for users to log in was assumed
(but not implemented), this project explicitly removes the rewquirement that users
should log in. Thus, while creating the project, when a template is being chosen
in the New Project wizard, the authentication is removed by clicking the 
*Change Authentication* button and selecting the *No Authentication* option in the
next window.

#### 1.2. Install Entity Framework

If EF is missing, install it as follows:

1. Open Tools > Library/NuGet Package Manager > Package Manager Console
2. In the Package Manager Console, run the following command:

```
Install-Package EntityFramework
```

#### 1.3. Creating the Models

Models in an MVC application represent the data that will be used and persisted
to the database. The models have two kinds of properties:

* Those that are unique to the model. These represent the attributes of the model
itself. By default, any named *ID* or *classNameID* is used as the primary key
in the database. Using *ID* makes it easier to implement inheritance. Either way,
whichever mode is picked should be the one consistently used throughout.

* Those used to show an association/ a relationship between two models/entities.
Such properties are known as **_Navigation Properties_**. A navigation property
holds other entities that are related to this entity. Each relationship 
between models is defined by two ends, describing the entity type and the 
multiplicity of the type (one, zero-or-one, or many). Common relationships include
*one-to-many*, *one-to-one* and *many-to-many*.

The models used are as follows:

**(a). The Student Entity**

Each `Student` has a unique identifier, as well as properties to hold the name 
and enrollment date. A `Student` can have several `Enrollments`, which is, here,
a way to define the relationship between a `Student` and a `Course`. Having
multiple `Enrollment` objects shows that a single student can enroll in multiple
courses.

```c#
public class Student
{
    public int ID {  get; set; }    // primary key
    public string LastName { get; set; }
    public string FirstMidName { get; set; }
    public DateTime EnrollmentDate { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```

Navigation properties are typically declared as `virtual`, to take advantage of
Entity Framework functionality such as *lazy loading*. If a navigation property
can hold multiple entities (such as a many-to-many or one-to-many relationships),
then its type must be a list allowing CRUD operations.

**(b). The Enrollment Entity**

As noted earlier, `Enrollment` defines the relationship between a `Student` and
a `Course`. Each `Enrollment` object has a unique identifier and a `Grade`. It 
also holds references to the `Student` and `Course` objects that together create
this `Enrollment`; the `ID` fields of each are the foreign keys for each 
`Enrollment` item into its respective `Student` and `Course` rows. 

```c#
public enum Grade
{
    A, B, C, D, F
}
public class Enrollment
{
    // primary key
        public int ID { get; set; }
 
        // nullable; null grade != zero grade
        public Grade? Grade { get; set; }

        // foreign keys
        public int CourseID { get; set; }   
        public int StudentID { get; set; } 

        // navigation properties
        // one-to-one relationship with both
        public virtual Course Course { get; set; } 
        public virtual Student Student { get; set; }
}
```

Entity Framework interprets a property as a foreign key if its name follows the
syntax *< navigation property name > < primary key property name >*, e.g. `StudentID`
for the `Student` navigation property, since `Student` is the navigation property
name, and `ID` is the primary key of `Student`. An alternative syntax used for
classes that use *classNameID* as the primary key is *< primary key property name >*,
(since the first format would result in, for instance, `StudentStudentID` if the
primary key of the `Student` model was `StudentID`).

**(c). The Course Entity**

The `Course` entity contains a unique identifier, a title and credits. It has a
reference to the collection of `Enrollment` objects that would include it, since
multiple students are allowed to enrol in any one course.

```c#
public class Course
{
    // primary key; have it not automatically generated by database.
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int ID { get; set; }

    public string Title { get; set; }
    public int Credits { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```
A view of all three models is as below: the second row in the table shows the
relationship of each entity to the one on its right (i.e. one-to-many and 
many-to-one)

| Course (one)  |Enrollment (many)  |Student (one)           |
|---------------|-------------------|------------------------|
| *Properties*  | *Properties*      | *Properties*           |
| int ID (PK)   | int ID (PK)       | int ID                 |
| string Title  | int CourseID (FK) | string LastName        |
| int Credits   | int StudentID (FK)| string FirstMidName    |
|               | Grade Grade       | DateTime EnrollmentDate|
|  *Nav Prop*   | *Nav Props*       | *Nav Prop*             |
| (ICollection) | Course Course     | (ICollection)          |
| Enrollments   | Student Student   | Enrollments            |


#### 1.4. Creating the Database Context

The database context class for this project will be *DataAccessLayer/SchoolContext*,
and will be as follows:

```c#
public class SchoolContext : DbContext
{
    public DbSet<Student> Students { get; set; }
    public DbSet<Enrollment> Enrollments { get; set; }
    public DbSet<Course> Courses { get; set; }

    public SchoolContext()
        : base("SchoolContext")
    { }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Conventions.Remove<PluralizingTableNameConvention>();
    }
}
```

**(a). Specifying entity sets**

The context creates a `DbSet` property for each *entity set*. In EF terminology,
an *entity set* typically corresponds to a database table, while an *entity*
corresponds to a row in the table.

The `Enrollment` and `Course` entity sets could have been left out, as EF would
have automatically created them since `Student` has references to `Enrollment`,
which in turn references `Course`.

**(b). Specifying the connection string**

The name of the database (which we'll also add to *Web.Config* later) is passed
as a parameter to the `DbContext` constructor. If one is not specified, EF assumes
that the connection string name is the same as the class name of the DbContext
(here, `SchoolContext`).

**(c). Specifying singular table names**

The `modelBuilder.Conventions.Remove` call prevents table names from being
pluralized, which is the usual onvention within ASP.NET. Hence the table names
will be `Student`, `Course` and `Enrollment` rathert han their plural versions.
This is merely a coding preference.

#### 1.4. Set Up EF Database Initialization

EF can automatically create (after an optional drop) a database. One can specify
that this happen when the application is run, or only when the model is out of
sync with the existing database, or only if no database exists (default). 

Here, we specify that the db be dropped and recreated any time the model changes.
This is ok in development, because the `Seed` method is called each time to
populate the db with the initial data. However, in production, *database migration*
is commonly used to update the database to the current schema, rather than dropping
the db and losing all data.

The database initialization code is placed in *DataAccesslayer/SchoolInitializer.cs*,
and is as follows:

```c#
public class SchoolInitializer : System.Data.Entity.DropCreateDatabaseIfModelChanges<SchoolContext>
{
    protected override void Seed(SchoolContext context)
    {
        // create list of students
        var students = new List<Student>
        {
            new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},
            new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}
        };

        // add each student to the related dbset
        students.ForEach(s => context.Students.Add(s));

        // persist the changes to the database
        context.SaveChanges();
        // we can leave the SaveChanges() call to the very end, but done here
        // out of an overabundance of caution.

        // repeat with courses
        var courses = new List<Course>
        {
            new Course{ID=1050,Title="Chemistry",Credits=3,},
            new Course{ID=4022,Title="Microeconomics",Credits=3,},
            new Course{ID=2042,Title="Literature",Credits=4,}
        };

        courses.ForEach(s => context.Courses.Add(s));

        context.SaveChanges();

        // and with enrollments
        var enrollments = new List<Enrollment>
        {
            new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},
            new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},
            new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},
            new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},
            new Enrollment{StudentID=3,CourseID=1050}
        };

        enrollments.ForEach(s => context.Enrollments.Add(s));

        context.SaveChanges();
    }
}
```

The `Seed` method takes the database context as a parameter, and the code uses
that context to add records to the database. For each entity type, the code creates
a list of entities, adds them to the appropriate DbSet property, then saves the
changes in the database. While it's not necessary to call `SaveChanges()` after
each entity set, calling it as we've done makes it easier to locate exceptions
that occur while the code is writing to the database.

Once the initializer is created, EF needs to be told to use it. The following
element is added to the `entityFramework` node in *Web.config*

```xml
<entityFramework>
    <contexts>
      <context type="ContosoUniversity.DataAccessLayer.SchoolContext, ContosoUniversity">
        <databaseInitializer type="ContosoUniversity.DataAccessLayer.SchoolInitializer, ContosoUniversity" />
      </context>
<!-- snippet -->
</entityFramework>
```

The `context type` specifies the fully qualified context class name and the
assembly it's in, while `databaseInitlizer type` does the same for the database
initializer class that contains the `Seed()` method. For more information on the
EF configuration settings, see [EF Config File Settings](http://msdn.microsoft.com/en-us/data/jj556606)

The application is now set up such that when you access the database for the 
first time in a given run, EF compares the database to the model (i.e. to the
`SchoolContext` schema and model classes) and if differences exist, it drops and
recreates the database.

> **Note**
> Obviously, deleting data and reseting the database to the base snapshot is
> discourageed in production environments. This tutorial will disable this
> initialization in later stages.

#### 1.5. Set up EF to use a SQL Express LocalDB Database

*LocalBD* is a lightweight version of *SQL Server Express* database engine. It
acta as an easy-to-set-up development database. To use it, add the following line
to *Web.Config*, preceding the `appSettings` element:

```xml
<connectionStrings>
    <add name="SchoolContext" connectionString="Data Source=(LocalDb)\v11.0;Initial Catalog=ContosoUniversity1;Integrated Security=SSPI;" providerName="System.Data.SqlClient"/>
</connectionStrings>
```

This specifies that EF is to use a LocalDB database named *ContosoUniversity1.mdf*.
If the database is to be created in the *App_Data/* folder, one could add the line
`AttachDBFileName=|DataDirectory|\ContosoUniversity1.mdf`.

#### 1.6. Creating a Student Controller and Views

To create the controller:

1. Right-click the *Controllers* folder, select Add > New Scaffolded Item
2. In the *Add Scaffold* dialig box, select *MVC 5 Controller with views, using*
*Entity Framework*
3. In the *Add Controller* dialog box, select the following options
    * Controller name: *StudentControler*
    * Model class: *Student (ContosoUniversity.Models)* (If you don't see this
    option in the dropdown list, build the project and try again).
    * Data context class: *SchoolContext (ContosoUniversity.DataAccessLayer)*
    * Leave the default values for the other fields.
4. Click *Add*

EF creates the *StudentController* class, while scaffolding creates the views of
the basic CRUD operations.

#### 1.7. Conventions

One of the reasons EF requires such minimal code is the conventions it has, which
allow it to make expectations of what the program structure would look like. A
few of those seen so far include:

1. The pluralized forms of entity/model class names are used as the table names
2. Entity/model property names become column names and form labels
3. Entity properties named *ID* or *classNameID* are used as the primary key.
4. Foreign keys are the properties whose names are formatted as follows:
*[ navigation property name ]* *[ navigation property primary key name]* (for 
instance, the `StudentID` property in *Models/Course.cs*, since `Student` is the
navigation property's name and `ID` is the name of the primary key of `Student`),
or the format *[ navigation property primary key name ]* if the primary key uses
the *classNameID* format for its primary key.


---


## 2. Implementing Basic CRUD Functionality


This section creates the views and controller actions required to correctly edit
and display the `Student` entities.

#### 2.1. Create a Details Page

The `Details()` action in StudentController is as shown below:

```c#
// GET: Students/Details/5
public ActionResult Details(int? id)
{
    if (id == null)
    {
        return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
    }
    Student student = db.Students.Find(id);
    if (student == null)
    {
        return HttpNotFound();
    }
    return View(student);
}
```

It finds a student matching the passed ID parameter and sends it to the Details
view. Since the `Student.Enrollments` property is a collection, the view does
not display it. In order to show the enrollments, the following code is added to
the *Details* view:

```cshtml
<!-- snippet -->
<dd>
    @Html.DisplayFor(model => model.EnrollmentDate)
</dd>

<!-- Add this code to display a list of enrollments -->

<dt>
    @Html.DisplayNameFor(model => model.Enrollments)
</dt>
<dd>
    <table class="table">
        <tr>
            <th>Course Title</th>
            <th>Grade</th>
        </tr>
        @foreach (var item in Model.Enrollments)
        {
            <tr>
                <td>
                    @Html.DisplayFor(modelItem => item.Course.Title)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.Grade)
                </td>
            </tr>
        }

    </table>
</dd>
```

The code loops though the `Enrollment` entity for each student, and displays the
courtse title and grade for each.

#### 2.2. Update the Create Page

Change the `Create` action to the following code:

```c#
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create([Bind(Include = "LastName,FirstMidName,EnrollmentDate")] Student student)
{
    try
    {
        if (ModelState.IsValid)
        {
            db.Students.Add(student);
            db.SaveChanges();
            return RedirectToAction("Index");
        }
    }
    catch(DataException /*dex */)
    {
        // log the error (uncommnet dex variable and add line here to log
        ModelState.AddModelError("", "Unable to save changes. Try again, or see your sysadmin");
    }

    return View(student);
}
```

We've removed the `ID` parameter from the *Bind* attribute, and wrapped the rest
of the code in a `try-catch` block. `ID` is removed because it is the primary key
and is automatically generated by the database. The `try-catch` adds some robustness
to the application, since `DataException` errors are sometimes caused by factors
external to the application.

#### 2.3. Update the Edit HttpPost Page

Change the `[HttpPost]` version of the `Edit` action to be:

```c#
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Edit([Bind(Include = "ID,LastName,FirstMidName,EnrollmentDate")] Student student)
{
    try
    {
        if (ModelState.IsValid)
        {
            db.Entry(student).State = EntityState.Modified;
            db.SaveChanges();
            return RedirectToAction("Index");
        }
    }
    catch (DataException /*dex */)
    {
        // log the error (uncommnet dex variable and add line here to log
        ModelState.AddModelError("", "Unable to save changes. Try again, or see your sysadmin");
    }

    return View(student);
}
```

Here, rather than adding the changed user to the database, the code sets a flag
on the entity indicating that the `Student` entity has been modified. When the
`SaveChanges()` method is called, the `Modified` flag causes EF to create SQL
code to update the row. All columns, including those not changed, will be updated,
and *concurrency conflicts* are ignored.

#### 2.4. Update the Delete Page

Much like the `Edit` and `Create` actions, delete operations require two action
methods. The first one, in response to a `GET`, displays a view that allows the
user to confirm or cancel the operation. If the operation is approved, the `POST`
request is created, and invokes the `HttpPost` version of the method.

The changes here will wrap the deletion in a `try-catch`. If an error s found,
the user is redirected to the `Get` version of the page and an error message 
displayed.

Repalce the `Get` version of `Delete` with the following:

```c#
// GET: Students/Delete/5
public ActionResult Delete(int? id, bool? saveChangesError = false)
{
    if(id == null)
    {
        return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
    }
    if(saveChangesError.GetValueOrDefault())
    {
        ViewBag.ErrorMessage = "Delete failed. Try again, or see your sysadmin";
    }

    Student student = db.Students.Find(id);
    if(student == null)
    {
        return HttpNotFound();
    }


    return View(student);
}
```

The method accepts an optional parameter that indicated whether the method was
called after a failure to save changes; the default vbalue is `false`. Being
a *nullable* value (as indicated by the `?` xcter in `bool? saveChangesError...`),
the code `saveChangesError.GetValueOrDefault()` method is used to return the
value of the variable.

Replace the `Post` version (here, `DeleteConfirmed()`) with the following:

```c#
// POST: Students/Delete/5
[HttpPost, ActionName("Delete")]
[ValidateAntiForgeryToken]
public ActionResult Delete(int id)
{
    try
    {
        Student student = db.Students.Find(id);
        db.Students.Remove(student);
        db.SaveChanges();
    }
    catch (DataException/* dex */)
    {
        // log the error after uncommenting the dex variable name
        return RedirectToAction("Delete", new {id = id, saveChangesError = true });
    }
    
    return RedirectToAction("Index");
}
```

Note that the name is now changed to `Delete`.

The code retrieves the desired entity, calls `Remove` on the context using that 
entity, then saves the changes (here, an SQL `DELETE` command is generated). If 
this operaton fails due to a `DatException` error, the caller is redirected to
the `Get` version of the `Delete` call with a new object holding the id and error
message.

This method generated SQL that may be constly in some applications. Tis may be
repalced with:

```c#
Student studentToDelete = new Student() { ID = id };
db.Entry(studentToDelete).State = EntityState.Deleted;
```

To complete the `Delete` code, add the following to the *Delete* view:

```cshtml
<!-- snippet -->
<h2>Delete</h2>
<p class="error">@ViewBag.ErrorMesage</p>
<h3>Are you sure you want to delete this?</h3>
<!-- snippet -->
```

#### 2.5. Closing/Disposing of Database Connections

To ensure all database connections are closed and resources freed, the context
instance must be disposed of once we're done with it. This is done by the `Dispose`
method at the end of the `StudentController` class, as shown:

```c#
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        db.Dispose();
    }
    base.Dispose(disposing);
}
```

The base `Controller` class already implememnts the `IDisposable` interface, so
this call simply acts as an override.

#### 2.6. Handling Transactions

EF automatically makes all transactions atomic; either all operations in the
transactions succeed, or all fail.

---


## 3. Add Sorting, Filtering and Pagination

This section adds the capability to sort and group students, as well as paginate
throuh the application.

#### 3.1. Add Sorting Functionality to the Students Index page

Replace `StudentController/Index()` wit the following code:

```c#
// GET: Students
public ActionResult Index(string sortOrder)
{
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";

    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    var students = from s in db.Students
                   select s;

    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    return View(students.ToList());
}
```

The method receives a parameter `sortOrder` as a query string; this parameter is
a string containing either "*Name*" or "*Date*", optionally followed by "*_desc*"
to specify descending order. The default sorting format is by last name, ascending.

When the `Index` method is called the first time, the sort parameter is empty, 
and the students are displayed in ascending order by `Lastname`. When a user
clicks on the column heading hyperlink (as implemented below), then the
appropriate `sortOrder` value is provided.

The ViewBag variables are used to allow the view to configure the column heading
hyperlinks.

The code uses LINQ to create the `IQueryable` variable, then the switch to 
determine the filter, and calls `ToList` to execute the query and pass the
resultant list to the view. Note that, unlike the original `Index` method which
returned `View(db.Students.ToList())` (i.e. a list of all the students, sans
filtering), this one returns `View(students.ToList())`, the (possibly filtered)
LINQ query. 

Change the *Index* view to be as follows:

```cshtml
<!-- snippet -->
<p>
    @Html.ActionLink("Create New", "Create")
</p>
<table class="table">
    <tr>
        <th>
            @Html.ActionLink("Last Name", "Index", new object { sortOrder = ViewBag.NameSortParm })
        </th>
        <th>
            First Name
        </th>
        <th>
            @Html.ActionLink("Enrollment Date", "Index", new object { sortOrder = ViewBag.NameSortParm })
        </th>
        <th>
            
        </th>
        <th></th>
    </tr>

@foreach (var item in Model) {

<!-- snippet -->

```

The code uses the information in the `ViewBag` properties to set up hyperlinks 
with the appropriate hyperlink values. This is because the value of the hyperlink
depends on what the last sort order was; the first time `Index` is invoked, 
`sortOrder` is null because no sorting has been asked for, and therefore `Index`
starts off by having `ViewBag.NameSortParm` be set to the sorting option that 
will be possible when the view is displayed (since the view sorts by last name 
ascending - the default setting - the first time `Index` is invoked, the link 
should allow sorting by last name descending, hence `NameSortParm` is set to 
`name_desc`). Similarly, the first time `Index` is invoked, sorting by enrollment
date is yet to be requested, so we set it to one of the available options. Hence
when sorting is invoked by one format, the link is to be set to the opposite
value when the view renders, hence the `ViewBag` property is reset.

#### 3.2. Add a Search Box to the Students Index Page

A search filter requires a textbox and a submit button on the view, and code in
the `Index` to handle the search request. Change it to the code below:

```c#
// GET: Students
public ActionResult Index(string sortOrder, string searchString)
{
    // set the sorting link parameters
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";
    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    var students = from s in db.Students
                   select s;

    // filter by search term
    if(!string.IsNullOrEmpty(searchString))
    {
        searchString = searchString.ToUpper();
        students = students.Where(s => s.LastName.ToUpper().Contains(searchString)
                                    || s.FirstMidName.ToUpper().Contains(searchString) );
    }            
    
    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    return View(students.ToList());
}
```

The change adds a filter to the `students` query if a search term is provided.
This filter is executed on the database itself (i.e. `Contains` is called as an
SQL statement, and is not the .NET `string.Contains(string)` method). Calling it
on the database rather than on an in-memory colection ensures the results are
consistent; .NET's `Contains()` returns all rows if an empty search string is
passed, while SQL's returns no row at all. Hence the search filter is called on
the database for consistency, and called within the `if` to make sure the search
string is not empty.

Change the Index view to the following:

```cshtml
<!-- snippet -->
<p>
    @Html.ActionLink("Create New", "Create")
</p>


@using(Html.BeginForm())
{
    <p>
        Find by name: @Html.TextBox("SearchString")
        <input type="submit" value="Search" />
    </p>
}

<table class="table">
    ...
</table>

<!-- snippet -->

```

The code above calls `BeginForm` to create the form fields required for the search.
Note that the url sent to the controller does not contain the search term within
it; the search terms are sent as a POST request. This will be changed later.

#### 3.3. Adding Paging to the Students Index Page

Start by installing the *PagedList.Mvc*, one of the many paging and sorting
packages for ASP.NET MVC, used here as an example rather than as a recommendation
over other options.

Click *Tools > Library > NuGet Package Manager > Package Manager Console*, and 
type the command below:

```
Install-Package PagedList.Mvc
```

Add `using PagedList` to the *StudentController.cs* file, and replace the `Index`
method with the following code:

```c#
// GET: Students
        public ActionResult Index(string sortOrder, string searchString, string currentFilter, int? page)
{
    ViewBag.CurrentSort = sortOrder;

    // set the sorting link parameters
    ViewBag.NameSortParm = string.IsNullOrEmpty(sortOrder) ?
        "name_desc" : "";
    ViewBag.DateSortParm = sortOrder == "Date" ?
        "date_desc" : "Date";

    if(searchString != null)
    {
        page = 1;
    }
    else
    {
        searchString = currentFilter;
    }

    ViewBag.CurrentFilter = searchString;
    
    var students = from s in db.Students
                   select s;

    // filter by search term
    if(!string.IsNullOrEmpty(searchString))
    {
        searchString = searchString.ToUpper();
        students = students.Where(s => s.LastName.ToUpper().Contains(searchString)
                                    || s.FirstMidName.ToUpper().Contains(searchString) );
    }            
    
    switch(sortOrder)
    {
        case "name_desc":
            students = students.OrderByDescending(s => s.LastName);
            break;

        case "Date":
            students = students.OrderBy(s => s.EnrollmentDate);
            break;

        case "date_desc":
            students = students.OrderByDescending(s => s.EnrollmentDate);
            break;

        default:
            students = students.OrderBy(s => s.LastName);
            break;
    }

    int pageSize = 3;
    int pageNumber = (page ?? 1);

    return View(students.ToPagedList(pageNumber, pageSize));
}
```

We've added current filter and page parameters to the method signature. The first
time the page is displayed, all 4 parameters will be empty.

Each navigation to a new page will result in a call to the `Index` method. The 
sort order will ahve to be maintained throughout these calls, so the first line
(`Viewbag.CurrentSort = sortOrder`) caches the sort order between views/pages.

The property `Viewbag.CurrentFilter` provides a way to do the same with the
searchString filter. This allows it to be maintained throughout the paging, and 
be restored to the textbox when the page is changed. If the search string is reset
during paging, the page has to be reset to `1`, because the new filter can result
in different data to display (and therefore a different number of pages). Once
a saearch filter is entered and cached by `ViewBag.CurrentFilter`, subsequent
paginations send a null value of searchString, and it is rewritten as the value
of `string currentFilter`. If, however, some search string is entered, then
`searchString` is no longer null, and the page is reset to `1` as shown below:

```c#
if(searchString != null)
{
    page = 1;
}
else
{
    searchString = currentFilter;
}
```

Att he end of the method, the `ToPagedList` extension method on the `students`
`IQueryable` object converts the string query into a single page of students in
a collections that supports paging. This single page is then passed to the view:

```c#
int pageSize = 3;
int pageNumber = (page ?? 1);
return View(students.ToPagedList(pageNumber, pageSize));
```

The `ToPagedList` method takes two parameters; the first is the page number that
the view should report, while the second is the number of items each page can 
have.

> **Note**
> The `??` operator in the line `int pageNumber = (page ?? 1)` is known as the
> *null-coalescing operator*. Basically, it returns the left vale if it's not
> null, else the value on the right. Hence `pageNumber = page` if `page` is not
> null; if it is, then `pageNumber = 1`.

Change the Index view to reflect the changes, as follows:

* Remove the `@Model IEnumerable<ContosoUniversity.Models.Student>` line at the
top of the file.

* Add the following lines to the top of the file.

```cshtml
@model PagedList.IPagedList<ContosoUniversity.Models.Student>
@using PagedList.Mvc;

<link href="~/Content/PagedList.css" rel="stylesheet" type="text/css" />
```

The `@model` statement at the top specifies that the view now gets a `PagedList`
object instead of the `List` object it got before. The `using` statement adds a
reference to the `PagedList.Mvc` helper for the paging buttons.

* Use an overload of `BeginForm` to create a search url that can be bookmarked:

```cshtml
@using (Html.BeginForm("Index", "Student", "FormMethod.Get"))
{
    <p>
        Find by name: @Html.TextBox("SearchString", Viewbag.CurrentFilter as string)
        <input type="submit" value="Search" />
    </p>
}
```

The default `BeginForm` submits values as POSTed route data, rather than as query 
strings. Operations not altering the database or application state, such as
searching, are best called through GET operations.

The text box is initialized with the current search string so that each page has
the search filter value displayed within it when the page loads.

* Add the sorting filters to the column header links, to allow sorting on 
subsequent pages.

```cshtml
@Html.ActionLink("Last Name", "Index", new { sortOrder = Viewbag.NameSortParm, currentFilter = Viewbag.CurrentFilter})
```

* Show the current page and the total number of pages: add this to the bottom of
the file:

```cshtml
Page @(Model.PageCount < Model.PageNumber ? 0 : Model.PageNumber) of @Model.PageCount
```

This displays "Page 0 of 0" of there are no pages to display; `Model.PageNumber`
will be 1 (this is the lowest it can be, even if no results matching the search
filter are found), while `Model.PageCount` will be 0.

* Display the paging buttons; add the following code after the line above;

```cshtml
@html.PagedListPager(Model, page => Url.Action("Index", new { page }))
```

We can optionally have the `new { page }` portion include other values, and be
`new { page, sortOrder = ViewBag.CurrentSort, currentFilter = ViewBag.CurrentFilter }`.


#### 3.4. Create an About Page that shows Student Statistics

Tis section shows how to add a sumamry on the About page. The page will show how
many students have enrolled for each enrollment date. This will involve simple
calculations and grouping, and will be done in 3 steps:

* Create a view model class for the data you want to pass to the view
* Modify the `About` method in the `Home` controller.
* Modify the *About* view.

First, create a *ViewModels* folder and add the following model class to it:

```c#
namespace ContosoUniversity.ViewModels
{
    public class EnrollmentDateGroup
    {
        [DataType(DataType.Date)]
        public DateTime? EnrollmentDate { get; set; }

        public int StudentCount { get; set; }
    }
}
```

Then, add the following `using` statements to *HomeController.cs*:

```c#
using ContosoUniversity.DataAccessLayer;
using ContosoUniversity.ViewModels;
```

Add a class variable to hold the `SchoolContext` database context immediately
after the opening brace of the class, i.e:

```c#
public class HomeController : Controller
    {
        private SchoolContext db = new SchoolContext();

        // blah blah moar code
    }
```

Replace the `About` method with the following code:

```c#
public ActionResult About()
{
    IQueryable<EnrollmentDateGroup> data = from student in db.Students
                        group student by student.EnrollmentDate into dateGroup
                        select new EnrollmentDateGroup()
                        {
                            EnrollmentDate = dateGroup.Key,
                            StudentCount = dateGroup.Count()
                        };

    return View(data.ToList());
}
```

The LINQ statement groups the student entities by enrollment date, calculates the
number of entities in each group, and stores the results in a collection of
`EnrollmentDateGroup` view model objects.

Add a `Dispose` method

```c#
protected override void Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}
```

Modify the content of *Views/Home/About.cshtml* to the following:

```cshtml
@model IEnumerable<ContosoUniversity.ViewModels.EnrollmentDateGroup>

@{
    ViewBag.Title = "Student Body Statistics";
}
<h2>@ViewBag.Title.</h2>
<table>
    <tr>
        <th>
            Enrollment Date
        </th>
        <th>
            Students
        </th>
    </tr>
    @foreach (var item in Model)
    {
        <tr>
            <td>
                @Html.DisplayFor(modelItem => item.EnrollmentDate)
            </td>
            <td>
                @item.StudentCount
            </td>
        </tr>
    }
</table>
```



## 4. Connection Resiliency and Command Interception


To make an application avbailable to others, it has to be deployed to a web
hosting service, and the database to a database server. This section covers two
features of EF6 that come in extremely handy when deploying to the cloud:

Connection Resiliency - automatic retries of commands in response to transient 
errors, for instance, those caused by network load, throttling (i.e. having db
access throw exceptions when one acesses it more frequently than is allowed by
their Service Level Agreement), etc.

Command Interception - catching all SQL queries before they get to the database,
in order to log or change them. Used to implement logging of latency and success
or failure of database calls, a best practice of cloud applications. 

#### 4.1. Enable Connection Resiliency

These attempt to make application usage easier on end users by intercepting 
error messages from SQL queries that fail due to (possibly) transient errors, and
automatically retrying them. In order to do this, EF is configured such that it:

* knows which exceptions are likely to be transient
* waits an approrpiate amout of time betwen retries
* retries the failed command an appropriate amount of times

One can set these manually, or use the default values configured for Azure.
Connection resiliency is set by using a subclass of `DbConfiguration` that
defines the *SQL execution strategy*, EF's term for connection resiliency. This
is done as follows:

+ Create a file *DataAccessLayer/SchoolConfiguration.cs*.
+ Replace the template code with the following:

```c#
using System.Data.Entity;
using System.Data.Entity.SqlServer;

namespace ContosoUniversity.DataAccessLayer
{
    public class SchoolConfiguration : DbConfiguration
    {
        public SchoolConfiguration()
        {
            SetExecutionStrategy("System.Data.SqlClient", 
                                    () => new SqlAzureExecutionStrategy());
        }
    }
}
``` 
EF automatically runs any code it finds in a class that derives from `DbConfiguration`,
so configuration tasks that are better written in code than in *Web.Config* can
be added here.

+ In *StudentController.cs*, add `using System.Data.Entity.Infrastructure;`.
+ Change all the catch blocks so they catch `RetryLimitedExceedException` rather
than `DataException`. We used `DataException` to catch transient errors and give
a friendly "Try Again" message; with the sql execution policy we've set, transient
errors will already have been retried and failed, and all others will be now be
wrapped in a `RetryLimitExceededException`.

#### 4.2. Enable Command Interception

While EF6 incorporates a logging API, we'll use command interception to implement
a simple logger, as well as test the command resiliency feature.

> **Note**
> Logger is as implemeted in *Logger/* directory; not added here for brevity.
> Interceptor classes (one for logging, the other to simulate transient errors)
> are in the *DataAccesslayer/* directory; again, left out for brevity.

The interceptor is derived from the `DbCommandInterceptor` class, which gives us
the ability tointercept database commands before they execute against the db, as
well as being informed after the database command has been executed. There are
two kinds of methods that allow this:

1. **Executing methods** - these are intercepting methods that are called before
an action is exeuted on the database, to either inspect the context of the action

2. **Executed methods** - these are intercepting methods that are called after a
command has been executed, allowing one to inspect the result of a call before it
goes back to the calling method.

These methods are provided for each of the following method types:

1. **NonQuery methods** - commands not intended to retrieve data from the database,
i.e. upsert (insert &/or update) operations.

2. **Reader Methods** - commands intended to retrieve sets of data for iteration
and examination, e.g. `select * from users`

3. **Scalar Methods** - commands intended to retrieve a single method from the
database, e.g. `select count(*) from users`

Each of these methods takes as parameters at least two objects:

1. an object derived from the `DbInterceptionContext`, containing the contextual
information about the action EF is taking; for instance, if the action is being
performed on behalf of a `DbContext`, then the `DbContext` is passed as part of 
the `DbInterceptionContext` object. 

2. The command being executed.

When a command is re-executed due to transient errors, EF has an exponential
backoff duration between repeated calls.

> **NOTE**
> Current tutorial state is to fail upon entering "Throw" [sans quotes] in the
> search box on the "Student" page.


## 5. Code First Migrations and Deployment'


This section enables Code First migrations (to allow changes to the data model 
without having to drop and recreate the db) and, optionally, deploys the app to
a Windows Azure website.

#### 5.1. Enable Code First Migrations

Currently, the app is configured to drop and reset/recreate the database with
each model/data change. While this wrks in testing envronments, it won't suit
production environments. *Code First Migrations* allows for the database schema
to be updated without dropping and recreating the database, preserving production
data.

> **Note**
> The notes skip the setup and pick up from the "*Set up the Seed Method*" portion.

Once migrations are enabled, EF creates a *Migrations/Configuration.cs* file with
the method `Seed(DbContext)`. This method is called each time the db is created
or updated after a schema or data model change.

Since the `Seed` method is called in production each time the database schema is
updated, its best to have it add production data rather than test data to the
database. This is done by changing the method as the snippet below shows:

```c#
protected override void Seed(ContosoUniversity.DataAccessLayer.SchoolContext context)
{
    // create list of students
    var students = new List<Student>
    {
        new Student { FirstMidName = "Carson", LastName = "Alexander", 
            EnrollmentDate = DateTime.Parse("2010-09-01")},

        // snippet cut off

        new Student { FirstMidName = "Brad", LastName = "Thornton", 
            EnrollmentDate = DateTime.Parse("2000-09-01")}
    };

    // add each student to the db
    students.ForEach(s => context.Students.AddOrUpdate(p => p.LastName, s));
    // save changes
    context.SaveChanges();

    // repeat with courses
    var courses = new List<Course>
    {
        new Course {ID = 1050, Title = "Chemistry", Credits = 3, },

        //...

        new Course {ID = 2042, Title = "Literature", Credits = 4, }
    };

    courses.ForEach(s => context.Courses.AddOrUpdate(p => p.Title, s));

    context.SaveChanges();

    // then enrollments
    var enrollments = new List<Enrollment> 
    {
        new Enrollment 
        {
            StudentID = students.Single(s => s.LastName == "Alexander").ID,
            CourseID = courses.Single(c => c.Title == "Chemistry").ID,
            Grade = Grade.A
        },

        // ...

        new Enrollment
        { 
            StudentID = students.Single(s => s.LastName == "Thornton").ID,
            CourseID = courses.Single(c => c.Title == "Literature").ID,
            Grade = Grade.C         
        }
    };

    // add enrollments to db

    foreach (Enrollment e in enrollments)
    {
    var enrollmentInDatabase = context.Enrollments.Where (s => 
        s.Student.ID == e.StudentID && s.Course.ID == e.CourseID)
        .SingleOrDefault();
             
        if(enrollmentInDatabase == null)
        {
            context.Enrollments.Add(e);
        }
    }

}
```

The method takes a `DbContext` parameter, and uses it to add new entities to the
database. For each model, it creates a list containing the entities, then adds
them to the appropriate `DbSet` before finally pushing the changes to the db to 
be persisted.

The `Student` and `Course` entities are added via an *upsert* operation, to
avoid errors that occur when one tries to add a row that already exists. The 
first parameter to the `AddOrUpdate` upsert method specifies the property to use
to check if a row already exists, while the second specifies the entity to actually
add or update, e.g:

```c#
students.ForEach(s => context.Students.AddOrUpdate(p => p.LastName, s));
```

Essentially, for each `Student` `s`, update the record of `Student` object  `p` 
where `p.LastName` matches `s.LastName`, or add it to the database is none is found. 
If multiple `Student` objects are found matching `s.LastName`, an exception is 
thrown with the message *Sequence contains more than one element*.

After each entity set is added to the context, `SaveChanges()` is called to persist
the changes to the database. This not only helps make it easier to track down errors
that occur during the method (by seeing what's been written to the database), but
also makes database-generated properties available for later portions of the same
`Seed` method. For instance, the code that creates `Enrollment` objects is as 
follows:

```c#
new Enrollment
{
    StudentID = students.Single(s => s.LastName == "Alonso").ID,
    CourseID = courses.Single(c => c.Title == "Macroeconomics").ID,
    Grade = Grade.A
}
```

Here, the `StudentID` is set to the `ID` of some student, despite the fact that
the `ID` is a database-generated property not defined by the application (hence
no `ID` property in the list of students in `Seed`). EF automatically gets the
ID value when the `Student` entity is added to the db, and updates the entity in
memory.

The code that adds each `Enrollment` property is as follows:

```c#
foreach(Enrollment e in enrollments)
{
    var enrollmentInDatabase = context.Enrollments.Where( s => 
            s.Student.ID == e.Student.ID && s.Course.ID == e.Course.ID)
            .SingleOrDefault();

    if(enrollmentInDatabase == null)
    {
        context.Enrollments.Add(e);
    }

}
```

This code checks if an `Enrollment` entity already exists, and adds it if it
doesn't. Unlike `AddOrUpdate`, it does not update any existing rows. This makes
sure that data changed via the application remains updated, and is not overwritten
by the `Seed` method. Note that this isn't used for the `Student` and `Course`
entities; conceptually, a student's name and enrollment date, or a course's name,
won't change, but grades are likely to. This means of adding data ensures the
changes remain intact.

Within the *Migrations* folder, EF creates a file whose name matches the pattern
*Timestamp*_*MigrationName.cs*. This file contains the SQL code called to create
the database during the migration, withn the `Up` method, and code to roll the
changes back within the `Down` method.

> **Note**
> Section 5.2 Deploying to Windows Azure left out.







