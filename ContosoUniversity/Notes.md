# Getting Started with Entity Framework 6 using MVC 5

#### Source
[Entity Framework 6]
(http://www.asp.net/mvc/tutorials/getting-started-with-ef-using-mvc/creating-an-entity-framework-data-model-for-an-asp-net-mvc-application "Microsoft ASP.NET")

## 1. Creating and Entity Framework Data Model


This section explains how the new project is set up.

#### 1.1 Initial Setup

Unlike the *MvcMovie* project, where the ability for users to log in was assumed
(but not implemented), this project explicitly removes the rewquirement that users
should log in. Thus, while creating the project, when a template is being chosen
in the New Project wizard, the authentication is removed by clicking the 
*Change Authentication* button and selecting the *No Authentication* option in the
next window.

#### 1.2. Install Entity Framework

If EF is missing, install it as follows:

1. Open Tools > Library/NuGet Package Manager > Package Manager Console
2. In the Package Manager Console, run the following command:

```
Install-Package EntityFramework
```

#### 1.3. Creating the Models

Models in an MVC application represent the data that will be used and persisted
to the database. The models have two kinds of properties:

* Those that are unique to the model. These represent the attributes of the model
itself. By default, any named *ID* or *classNameID* is used as the primary key
in the database. Using *ID* makes it easier to implement inheritance. Either way,
whichever mode is picked should be the one consistently used throughout.

* Those used to show an association/ a relationship between two models/entities.
Such properties are known as **_Navigation Properties_**. A navigation property
holds other entities that are related to this entity. Each relationship 
between models is defined by two ends, describing the entity type and the 
multiplicity of the type (one, zero-or-one, or many). Common relationships include
*one-to-many*, *one-to-one* and *many-to-many*.

The models used are as follows:

**(a). The Student Entity**

```c#
public class Student
{
    public int ID {  get; set; }    // primary key
    public string LastName { get; set; }
    public string FirstMidName { get; set; }
    public DateTime EnrollmentDate { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```

Navigation properties are typically declared as `virtual`, to take advantage of
Entity Framework functionality such as *lazy loading*. If a navigation property
can hold multiple entities (such as a many-to-many or one-to-many relationships),
then its type must be a list allowing CRUD operations.

**(b). The Enrollment Entity**

```c#
public enum Grade
{
    A, B, C, D, F
}
public class Enrollment
{
    // primary key
        public int ID { get; set; }
 
        // nullable; null grade != zero grade
        public Grade? Grade { get; set; }

        // foreign keys
        public int CourseID { get; set; }   
        public int StudentID { get; set; } 

        // navigation properties
        // one-to-one relationship with both
        public virtual Course Course { get; set; } 
        public virtual Student Student { get; set; }
}
```

Entity Framework interprets a property as a foreign key if its name follows the
syntax *< navigation property name > < primary key property name >*, e.g. `StudentID`
for the `Student` navigation property, since `Student` is the navigation property
name, and `ID` is the primary key of `Student`. An alternative syntax used for
classes that use *classNameID* as the primary key is *< primary key property name >*,
(since the first format would result in, for instance, `StudentStudentID` if the
primary key of the `Student` model was `StudentID`).

**(c). The Course Entity**

```c#
public class Course
{
    // primary key; have it not automatically generated by database.
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int ID { get; set; }

    public string Title { get; set; }
    public int Credits { get; set; }

    // navigation property
    public virtual ICollection<Enrollment> Enrollments { get; set; }
}
```

#### 1.4. Creating the Database Context

The database context class for this project will be *DataAccessLayer/SchoolContext*,
and will be as follows:

```c#
public class SchoolContext : DbContext
{
    public DbSet<Student> Students { get; set; }
    public DbSet<Enrollment> Enrollments { get; set; }
    public DbSet<Course> Courses { get; set; }

    public SchoolContext()
        : base("SchoolContext")
    { }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Conventions.Remove<PluralizingTableNameConvention>();
    }
}
```

**(a). Specifying entity sets**

The context creates a `DbSet` property for each *entity set*. In EF terminology,
an *entity set* typically corresponds to a database table, while an *entity*
corresponds to a row in the table.

The `Enrollment` and `Course` entity sets could have been left out, as EF would
have automatically created them since `Student` has references to `Enrollment`,
which in turn references `Course`.

**(b). Specifying the connection string**

The name of the database (which we'll also add to *Web.Config* later) is passed
as a parameter to the `DbContext` constructor. If one is not specified, EF assumes
that the connection string name is the same as the class name of the DbContext
(here, `SchoolContext`).

**(c). Specifying singular table names**

The `modelBuilder.Conventions.Remove` call prevents table names from being
pluralized, which is the usual onvention within ASP.NET. Hence the table names
will be `Student`, `Course` and `Enrollment` rathert han their plural versions.
This is merely a coding preference.

#### 1.4. Set Up EF Database Initialization

EF can automatically create (after an optional drop) a database. One can specify
that this happen when the application is run, or only when the model is out of
sync with the existing database, or only if no database exists (default). 

Here, we specify that the db be dropped and recreated any time the model changes.
This is ok in development, because the `Seed` method is called each time to
populate the db with the initial data. However, in production, *database migration*
is commonly used to update the database to the current schema, rather than dropping
the db and losing all data.

The database initialization code is placed in *DataAccesslayer/SchoolInitializer.cs*,
and is as follows:

```c#
public class SchoolInitializer : System.Data.Entity.DropCreateDatabaseIfModelChanges<SchoolContext>
{
    protected override void Seed(SchoolContext context)
    {
        // create list of students
        var students = new List<Student>
        {
            new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},
            new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}
        };

        // add each student to the related dbset
        students.ForEach(s => context.Students.Add(s));

        // persist the changes to the database
        context.SaveChanges();
        // we can leave the SaveChanges() call to the very end, but done here
        // out of an overabundance of caution.

        // repeat with courses
        var courses = new List<Course>
        {
            new Course{ID=1050,Title="Chemistry",Credits=3,},
            new Course{ID=4022,Title="Microeconomics",Credits=3,},
            new Course{ID=2042,Title="Literature",Credits=4,}
        };

        courses.ForEach(s => context.Courses.Add(s));

        context.SaveChanges();

        // and with enrollments
        var enrollments = new List<Enrollment>
        {
            new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},
            new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},
            new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},
            new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},
            new Enrollment{StudentID=3,CourseID=1050}
        };

        enrollments.ForEach(s => context.Enrollments.Add(s));

        context.SaveChanges();
    }
}
```

The `Seed` method takes the database context as a parameter, and the code uses
that context to add records to the database. For each entity type, the code creates
a list of entities, adds them to the appropriate DbSet property, then saves the
changes in the database. While it's not necessary to call `SaveChanges()` after
each entity set, calling it as we've done makes it easier to locate exceptions
that occur while the code is writing to the database.

Once the initializer is created, EF needs to be told to use it. The following
element is added to the `entityFramework` node in *Web.config*

```xml
<entityFramework>
    <contexts>
      <context type="ContosoUniversity.DataAccessLayer.SchoolContext, ContosoUniversity">
        <databaseInitializer type="ContosoUniversity.DataAccessLayer.SchoolInitializer, ContosoUniversity" />
      </context>
<!-- snippet -->
</entityFramework>
```

The `context type` specifies the fully qualified context class name and the
assembly it's in, while `databaseInitlizer type` does the same for the database
initializer class that contains the `Seed()` method. For more information on the
EF configuration settings, see [EF Config File Settings](http://msdn.microsoft.com/en-us/data/jj556606)

The application is now set up such that when you access the database for the 
first time in a given run, EF compares the database to the model (i.e. to the
`SchoolContext` schema and model classes) and if differences exist, it drops and
recreates the database.

> **Note**
> Obviously, deleting data and reseting the database to the base snapshot is
> discourageed in production environments. This tutorial will disable this
> initialization in later stages.

#### 1.5. Set up EF to use a SQL Express LocalDB Database

*LocalBD* is a lightweight version of *SQL Server Express* database engine. It
acta as an easy-to-set-up development database. To use it, add the following line
to *Web.Config*, preceding the `appSettings` element:

```xml
<connectionStrings>
    <add name="SchoolContext" connectionString="Data Source=(LocalDb)\v11.0;Initial Catalog=ContosoUniversity1;Integrated Security=SSPI;" providerName="System.Data.SqlClient"/>
</connectionStrings>
```

This specifies that EF is to use a LocalDB database named *ContosoUniversity1.mdf*.
If the database is to be created in the *App_Data/* folder, one could add the line
`AttachDBFileName=|DataDirectory|\ContosoUniversity1.mdf`.

#### 1.6. Creating a Student Controller and Views

To create the controller:

1. Right-click the *Controllers* folder, select Add > New Scaffolded Item
2. In the *Add Scaffold* dialig box, select *MVC 5 Controller with views, using*
*Entity Framework*
3. In the *Add Controller* dialog box, select the following options
    * Controller name: *StudentControler*
    * Model class: *Student (ContosoUniversity.Models)* (If you don't see this
    option in the dropdown list, build the project and try again).
    * Data context class: *SchoolContext (ContosoUniversity.DataAccessLayer)*
    * Leave the default values for the other fields.
4. Click *Add*

EF creates the *StudentController* class, while scaffolding creates the views of
the basic CRUD operations.

#### 1.7. Conventions

One of the reasons EF requires such minimal code is the conventions it has, which
allow it to make expectations of what the program structure would look like. A
few of those seen so far include:

1. The pluralized forms of entity/model class names are used as the table names
2. Entity/model property names become column names and form labels
3. Entity properties named *ID* or *classNameID* are used as the primary key.
4. Foreign keys are the properties whose names are formatted as follows:
*[ navigation property name ]* *[ navigation property primary key name]* (for instance, the
`StudentID` property in *Models/Course.cs*, since `Student` is the navigation
property's name and `ID` is the name of the primary key of `Student`), or the
format *[ navigation property primary key name ]* if the primary key uses the
*classNameID* format for its primary key.


---


## 2. Implementing Basic CRUD Functionality